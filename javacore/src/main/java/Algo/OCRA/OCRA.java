package Algo.OCRA;


import org.apache.commons.lang3.StringUtils;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import static Algo.TOTP.CommonUtils.hexStrToBytes;

/**
 * The definition of OCRA requires a cryptographic function, a key K and a set of DataInput parameters
 *
 *  DataInput = {OCRASuite | 00 | C | Q | P | S | T} where:
 * 	- OCRASuite is a value representing the suite of operations to compute an OCRA response
 * 	-  00 is a byte value used as a separator
 * 	-  C is an unsigned 8-byte counter value processed high-order bit
 * 	-  Q (mandatory) is a 128-byte list of (concatenated) challenge question(s) generated by the parties
 * 	-  P is a hash (SHA-1, SHA-256 and SHA-512) value of PIN/password that is known to all parties
 * 	-  S is a UTF-8 encoded string that contains information about the current session
 * 	-  T is a number of time-steps (seconds, minutes, hours) since midnight UTC of January 1, 1970
 *
 *  Note that all paramemters except for 'Q' are optional
 */
public class OCRA {
    private OCRA() {
    }

    /**
     * This method uses the JCE to provide the crypto
     * algorithm.
     * HMAC computes a Hashed Message Authentication Code with the
     * crypto hash algorithm as a parameter.
     *
     * @param crypto     the crypto algorithm (HmacSHA1, HmacSHA256,
     *                                   HmacSHA512)
     * @param keyBytes   the bytes to use for the HMAC key
     * @param text       the message or text to be authenticated.
     */
    private static byte[] hmac_sha(String crypto, byte[] keyBytes, byte[] text) {
        Mac hmac = null;
        try {
            hmac = Mac.getInstance(crypto);
            SecretKeySpec macKey = new SecretKeySpec(keyBytes, "RAW");
            hmac.init(macKey);
            return hmac.doFinal(text);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private static final int[] DIGITS_POWER
            // 0 1  2   3    4     5      6       7        8
            = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};

    /**
     * This method generates an OCRA HOTP value for the given
     * set of parameters.
     *
     * @param ocraSuite          the OCRA Suite
     * @param key                the shared secret, HEX encoded
     * @param counter            the counter that changes on a per use basis, HEX encoded
     * @param question           the challenge question, HEX encoded
     * @param password           a password that can be used, HEX encoded
     * @param sessionInformation Static information that identifies the current session, Hex encoded
     * @param timeStamp          a value that reflects a time
     *
     * @return A numeric String in base 10 that includes truncationDigits digits
     */
    static public String generateOCRA(String ocraSuite,
                                      String key,
                                      String counter,
                                      String question,
                                      String password,
                                      String sessionInformation,
                                      String timeStamp) {
        int codeDigits = 0;
        String crypto = "";
        String result = null;
        int ocraSuiteLength = (ocraSuite.getBytes()).length;
        int counterLength = 0;
        int questionLength = 0;
        int passwordLength = 0;
        int sessionInformationLength = 0;
        int timeStampLength = 0;

        // The OCRASuites components
        String CryptoFunction = ocraSuite.split(":")[1];
        String DataInput = ocraSuite.split(":")[2];

        // example: HTOP-SHA1-4
        if (CryptoFunction.toLowerCase().indexOf("sha1") > 1)
            crypto = "HmacSHA1";
        if (CryptoFunction.toLowerCase().indexOf("sha256") > 1)
            crypto = "HmacSHA256";
        if (CryptoFunction.toLowerCase().indexOf("sha512") > 1)
            crypto = "HmacSHA512";

        // How many digits should we return
        codeDigits = Integer.decode(CryptoFunction.substring(CryptoFunction.lastIndexOf("-") + 1));

        // The size of the byte array message to be encrypted
        // Counter - 8bytes (according to rfc)
        if (DataInput.toLowerCase().startsWith("c")) {
            // Fix the length of the HEX string
            counter = StringUtils.leftPad(counter, 16, '0');
            counterLength = 8;
        }
        // Question - always 128 bytes; (optional c -> -q)
        if (DataInput.toLowerCase().startsWith("q") || (DataInput.toLowerCase().contains("-q"))) {
            question = StringUtils.leftPad(question, 256, '0');
            questionLength = 128;
        }

        // password hash -> must be hex string -> bytesLen = 1/2 strLen
        // Password - sha1
        if (DataInput.toLowerCase().indexOf("psha1") > 1) {
            password = StringUtils.leftPad(password, 40, '0');
            passwordLength = 20;
        }

        // Password - sha256
        if (DataInput.toLowerCase().indexOf("psha256") > 1) {
            password = StringUtils.leftPad(password, 64, '0');
            passwordLength = 32;
        }

        // Password - sha512
        if (DataInput.toLowerCase().indexOf("psha512") > 1) {
            password = StringUtils.leftPad(password, 128, '0');
            passwordLength = 64;
        }

        // sessionInformation - s064
        if (DataInput.toLowerCase().indexOf("s064") > 1) {
            sessionInformation = StringUtils.leftPad(sessionInformation, 128, '0');
            sessionInformationLength = 64;
        }

        // sessionInformation - s128
        if (DataInput.toLowerCase().indexOf("s128") > 1) {
            sessionInformation = StringUtils.leftPad(sessionInformation, 256, '0');
            sessionInformationLength = 128;
        }

        // sessionInformation - s256
        if (DataInput.toLowerCase().indexOf("s256") > 1) {
            sessionInformation = StringUtils.leftPad(sessionInformation, 512, '0');
            sessionInformationLength = 256;
        }

        // sessionInformation - s512
        if (DataInput.toLowerCase().indexOf("s512") > 1) {
            sessionInformation = StringUtils.leftPad(sessionInformation, 1024, '0');
            sessionInformationLength = 512;
        }

        // TimeStamp
        if (DataInput.toLowerCase().startsWith("t") || (DataInput.toLowerCase().indexOf("-t") > 1)) {
            timeStamp = StringUtils.leftPad(timeStamp, 16, '0');
            timeStampLength = 8;
        }

        // Remember to add "1" for the "00" byte delimiter
        byte[] msg = new byte[ocraSuiteLength + 1 +
                counterLength +
                questionLength +
                passwordLength +
                sessionInformationLength +
                timeStampLength];

        // Put the bytes of "ocraSuite" parameters into the message (first part of OCRA)
        byte[] bArray = ocraSuite.getBytes();
        System.arraycopy(bArray, 0, msg, 0, bArray.length);

        // Delimiter
        msg[bArray.length] = 0x00;

        // Put the bytes of "Counter" to the message (C part)
        // Input is HEX encoded
        if (counterLength > 0) {
            bArray = hexStrToBytes(counter);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1, bArray.length);
        }

        // Put the bytes of "question" to the message (Q part)
        // Input is text encoded
        if (questionLength > 0) {
            bArray = hexStrToBytes(question);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 + counterLength, bArray.length);
        }

        // Put the bytes of "password" to the message (P part)
        // Input is HEX encoded
        if (passwordLength > 0) {
            bArray = hexStrToBytes(password);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 + counterLength + questionLength, bArray.length);
        }

        // Put the bytes of "sessionInformation" to the message (S part)
        // Input is text encoded
        if (sessionInformationLength > 0) {
            bArray = hexStrToBytes(sessionInformation);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +
                    counterLength + questionLength +
                    passwordLength, bArray.length);
        }

        // Put the bytes of "time" to the message (T part)
        // Input is text value of minutes
        if (timeStampLength > 0) {
            bArray = hexStrToBytes(timeStamp);
            System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +
                            counterLength + questionLength +
                            passwordLength + sessionInformationLength, bArray.length);
        }

        // Step 1: Generate HMAC-SHA hash
        bArray = hexStrToBytes(key);
        byte[] hash = hmac_sha(crypto, bArray, msg);

        // put selected bytes into result int
        // Step 2: Dynamic truncation
        int offset = hash[hash.length - 1] & 0xf; // 4 LSB
        int binary = ((hash[offset] & 0x7f) << 24) |
                        ((hash[offset + 1] & 0xff) << 16) |
                        ((hash[offset + 2] & 0xff) << 8) |
                        (hash[offset + 3] & 0xff);

        // Step 3: Generate TOTP
        int otp = binary % DIGITS_POWER[codeDigits];
        return StringUtils.leftPad(Integer.toString(otp), codeDigits, '0');
    }
}
